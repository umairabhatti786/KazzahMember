"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generate = void 0;
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _path = _interopRequireDefault(require("path"));
var _picocolors = _interopRequireDefault(require("picocolors"));
var _sharp = _interopRequireDefault(require("sharp"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const logoFileName = "bootsplash_logo";
const xcassetName = "BootSplashLogo";
const androidColorName = "bootsplash_background";
const androidColorRegex = /<color name="bootsplash_background">#\w+<\/color>/g;
const ContentsJson = `{
  "images": [
    {
      "idiom": "universal",
      "filename": "${logoFileName}.png",
      "scale": "1x"
    },
    {
      "idiom": "universal",
      "filename": "${logoFileName}@2x.png",
      "scale": "2x"
    },
    {
      "idiom": "universal",
      "filename": "${logoFileName}@3x.png",
      "scale": "3x"
    }
  ],
  "info": {
    "version": 1,
    "author": "xcode"
  }
}
`;
const getStoryboard = _ref => {
  let {
    height,
    width,
    backgroundColor: hex
  } = _ref;
  const r = (parseInt("" + hex[1] + hex[2], 16) / 255).toPrecision(15);
  const g = (parseInt("" + hex[3] + hex[4], 16) / 255).toPrecision(15);
  const b = (parseInt("" + hex[5] + hex[6], 16) / 255).toPrecision(15);
  return `<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="21507" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <device id="retina4_7" orientation="portrait" appearance="light"/>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="21505"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController modalTransitionStyle="crossDissolve" id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" autoresizesSubviews="NO" userInteractionEnabled="NO" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                        <autoresizingMask key="autoresizingMask"/>
                        <subviews>
                            <imageView autoresizesSubviews="NO" clipsSubviews="YES" userInteractionEnabled="NO" contentMode="scaleAspectFit" image="BootSplashLogo" translatesAutoresizingMaskIntoConstraints="NO" id="3lX-Ut-9ad">
                                <rect key="frame" x="${(375 - width) / 2}" y="${(667 - height) / 2}" width="${width}" height="${height}"/>
                                <accessibility key="accessibilityConfiguration">
                                    <accessibilityTraits key="traits" image="YES" notEnabled="YES"/>
                                </accessibility>
                            </imageView>
                        </subviews>
                        <viewLayoutGuide key="safeArea" id="Bcu-3y-fUS"/>
                        <color key="backgroundColor" red="${r}" green="${g}" blue="${b}" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <accessibility key="accessibilityConfiguration">
                            <accessibilityTraits key="traits" notEnabled="YES"/>
                        </accessibility>
                        <constraints>
                            <constraint firstItem="3lX-Ut-9ad" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="Fh9-Fy-1nT"/>
                            <constraint firstItem="3lX-Ut-9ad" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="nvB-Ic-PnI"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="0.0" y="0.0"/>
        </scene>
    </scenes>
    <resources>
        <image name="${xcassetName}" width="${width}" height="${height}"/>
    </resources>
</document>
`;
};
const log = {
  error: text => console.log(_picocolors.default.red(text)),
  text: text => console.log(text),
  warn: text => console.log(_picocolors.default.yellow(text))
};
const toFullHexadecimal = hex => {
  const up = hex.toUpperCase().replace(/[^0-9A-F]/g, "");
  if (up.length === 6) {
    return "#" + up;
  }
  if (up.length === 3) {
    return "#" + up[0] + up[0] + up[1] + up[1] + up[2] + up[2];
  }
  log.error("--background-color value is not a valid hexadecimal color.");
  process.exit(1);
};
const generate = async _ref2 => {
  let {
    android,
    ios,
    workingPath,
    logoPath,
    assetsPath,
    backgroundColor,
    flavor,
    logoWidth,
    platforms
  } = _ref2;
  const platformsIncludesAndroid = platforms.includes("android");
  const platformsIncludesIOS = platforms.includes("ios");
  if (!platformsIncludesAndroid && !platformsIncludesIOS) {
    log.error("--platforms value does not include at least one supported platform.");
    process.exit(1);
  }
  const backgroundColorHex = toFullHexadecimal(backgroundColor);
  const image = (0, _sharp.default)(logoPath);
  const {
    format
  } = await image.metadata();
  if (format !== "png" && format !== "svg") {
    log.error("Input file is an unsupported image format");
    process.exit(1);
  }
  const logoHeight = await image.clone().resize(logoWidth).toBuffer().then(buffer => (0, _sharp.default)(buffer).metadata()).then(_ref3 => {
    let {
      height = 0
    } = _ref3;
    return height;
  });
  const shouldSkipAndroid = logoWidth > 288 || logoHeight > 288;
  const logAbove288 = dimension => {
    const message = `⚠️   Logo ${dimension} exceed 288dp. As it will be cropped by Android, we skip generation for this platform.`;
    log.warn(message);
  };
  const logAbove192 = dimension => {
    const message = `⚠️   Logo ${dimension} exceed 192dp. It might be cropped by Android.`;
    log.warn(message);
  };
  if (logoWidth > 288) {
    logAbove288("width");
  } else if (logoHeight > 288) {
    logAbove288("height");
  } else if (logoWidth > 192) {
    logAbove192("width");
  } else if (logoHeight > 192) {
    logAbove192("height");
  }
  const logWrite = (emoji, filePath, dimensions) => log.text(`${emoji}  ${_path.default.relative(workingPath, filePath)}` + (dimensions != null ? ` (${dimensions.width}x${dimensions.height})` : ""));
  if (assetsPath) {
    log.text(`\n    ${_picocolors.default.underline("Assets")}`);
    _fsExtra.default.ensureDirSync(assetsPath);
    await Promise.all([{
      ratio: 1,
      suffix: ""
    }, {
      ratio: 1.5,
      suffix: "@1,5x"
    }, {
      ratio: 2,
      suffix: "@2x"
    }, {
      ratio: 3,
      suffix: "@3x"
    }, {
      ratio: 4,
      suffix: "@4x"
    }].map(_ref4 => {
      let {
        ratio,
        suffix
      } = _ref4;
      const fileName = `${logoFileName}${suffix}.png`;
      const filePath = _path.default.resolve(assetsPath, fileName);
      return image.clone().resize(logoWidth * ratio).png({
        quality: 100
      }).toFile(filePath).then(_ref5 => {
        let {
          width,
          height
        } = _ref5;
        logWrite("✨", filePath, {
          width,
          height
        });
      });
    }));
  }
  if (platformsIncludesAndroid && android && !shouldSkipAndroid) {
    log.text(`\n    ${_picocolors.default.underline("Android")}`);
    const appPath = android.appName ? _path.default.resolve(android.sourceDir, android.appName) : _path.default.resolve(android.sourceDir); // @react-native-community/cli 2.x & 3.x support

    const resPath = _path.default.resolve(appPath, "src", flavor, "res");
    const valuesPath = _path.default.resolve(resPath, "values");
    _fsExtra.default.ensureDirSync(valuesPath);
    const colorsXmlPath = _path.default.resolve(valuesPath, "colors.xml");
    const colorsXmlEntry = `<color name="${androidColorName}">${backgroundColorHex}</color>`;
    if (_fsExtra.default.existsSync(colorsXmlPath)) {
      const colorsXml = _fsExtra.default.readFileSync(colorsXmlPath, "utf-8");
      if (colorsXml.match(androidColorRegex)) {
        _fsExtra.default.writeFileSync(colorsXmlPath, colorsXml.replace(androidColorRegex, colorsXmlEntry), "utf-8");
      } else {
        _fsExtra.default.writeFileSync(colorsXmlPath, colorsXml.replace(/<\/resources>/g, `    ${colorsXmlEntry}\n</resources>`), "utf-8");
      }
      logWrite("✏️ ", colorsXmlPath);
    } else {
      _fsExtra.default.writeFileSync(colorsXmlPath, `<resources>\n    ${colorsXmlEntry}\n</resources>\n`, "utf-8");
      logWrite("✨", colorsXmlPath);
    }
    await Promise.all([{
      ratio: 1,
      directory: "mipmap-mdpi"
    }, {
      ratio: 1.5,
      directory: "mipmap-hdpi"
    }, {
      ratio: 2,
      directory: "mipmap-xhdpi"
    }, {
      ratio: 3,
      directory: "mipmap-xxhdpi"
    }, {
      ratio: 4,
      directory: "mipmap-xxxhdpi"
    }].map(_ref6 => {
      let {
        ratio,
        directory
      } = _ref6;
      const fileName = `${logoFileName}.png`;
      const filePath = _path.default.resolve(resPath, directory, fileName);
      // https://github.com/androidx/androidx/blob/androidx-main/core/core-splashscreen/src/main/res/values/dimens.xml#L22
      const canvasSize = 288 * ratio;

      // https://sharp.pixelplumbing.com/api-constructor
      const canvas = (0, _sharp.default)({
        create: {
          width: canvasSize,
          height: canvasSize,
          channels: 4,
          background: {
            r: 255,
            g: 255,
            b: 255,
            alpha: 0
          }
        }
      });
      return image.clone().resize(logoWidth * ratio).toBuffer().then(input => canvas.composite([{
        input
      }]).png({
        quality: 100
      }).toFile(filePath)).then(() => {
        logWrite("✨", filePath, {
          width: canvasSize,
          height: canvasSize
        });
      });
    }));
  }
  if (platformsIncludesIOS && ios) {
    log.text(`\n    ${_picocolors.default.underline("iOS")}`);
    const {
      projectPath
    } = ios;
    const imagesPath = _path.default.resolve(projectPath, "Images.xcassets");
    if (_fsExtra.default.existsSync(projectPath)) {
      const storyboardPath = _path.default.resolve(projectPath, "BootSplash.storyboard");
      _fsExtra.default.writeFileSync(storyboardPath, getStoryboard({
        height: logoHeight,
        width: logoWidth,
        backgroundColor: backgroundColorHex
      }), "utf-8");
      logWrite("✨", storyboardPath);
    } else {
      log.text(`No "${projectPath}" directory found. Skipping iOS storyboard generation…`);
    }
    if (_fsExtra.default.existsSync(imagesPath)) {
      const imageSetPath = _path.default.resolve(imagesPath, xcassetName + ".imageset");
      _fsExtra.default.ensureDirSync(imageSetPath);
      _fsExtra.default.writeFileSync(_path.default.resolve(imageSetPath, "Contents.json"), ContentsJson, "utf-8");
      await Promise.all([{
        ratio: 1,
        suffix: ""
      }, {
        ratio: 2,
        suffix: "@2x"
      }, {
        ratio: 3,
        suffix: "@3x"
      }].map(_ref7 => {
        let {
          ratio,
          suffix
        } = _ref7;
        const fileName = `${logoFileName}${suffix}.png`;
        const filePath = _path.default.resolve(imageSetPath, fileName);
        return image.clone().resize(logoWidth * ratio).png({
          quality: 100
        }).toFile(filePath).then(_ref8 => {
          let {
            width,
            height
          } = _ref8;
          logWrite("✨", filePath, {
            width,
            height
          });
        });
      }));
    } else {
      log.text(`No "${imagesPath}" directory found. Skipping iOS images generation…`);
    }
  }
  log.text(`
 ${_picocolors.default.blue("┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓")}
 ${_picocolors.default.blue("┃")}  💖  ${_picocolors.default.bold("Love this library? Consider sponsoring!")}  ${_picocolors.default.blue("┃")}
 ${_picocolors.default.blue("┃")}  ${_picocolors.default.underline("https://github.com/sponsors/zoontek")}          ${_picocolors.default.blue("┃")}
 ${_picocolors.default.blue("┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛")}
`);
  log.text(`✅  Done! Thanks for using ${_picocolors.default.underline("react-native-bootsplash")}.`);
};
exports.generate = generate;
//# sourceMappingURL=generate.js.map